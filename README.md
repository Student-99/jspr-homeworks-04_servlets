<details><summary># Домашнее задание к занятию «2.1. Servlet Containers»</summary>

В качестве результата пришлите ссылки на ваши GitHub-проекты в личном кабинете студента на сайте [netology.ru](https://netology.ru).

**Важно**: ознакомьтесь со ссылками, представленными на главной странице [репозитория с домашними заданиями](../README.md).

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

## Как сдавать задачи

1. Создайте на вашем компьютере Maven-проект
1. Инициализируйте в нём пустой Git-репозиторий
1. Добавьте в него готовый файл [.gitignore](../.gitignore)
1. Добавьте в этот же каталог остальные необходимые файлы
1. Сделайте необходимые коммиты
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub)
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru)

## CRUD

### Легенда

В рамках лекции мы реализовали практически полноценный In-Memory CRUD (Create Read Update Delete) сервер на базе сервлетов. Этому серверу не хватает двух вещей:
1. Причесать код (вынести методы в константы, убрать дублирующийся код)
1. Реализовать репозиторий (пока вместо репозитория установлена заглушка)

### Задача

1. Осуществите рефакторинг кода
1. Реализуйте репозиторий с учётом того, что методы репозитория могут вызываться конкурентно (т.е. в разных потоках)

Как должен работать `save`:
1. Если от клиента приходит пост с id = 0, значит это создание нового поста - вы сохраняете его в списке и присваиваете ему новый id (достаточно хранить счётчик с целым числом и увеличивать на 1 при создании каждого нового поста)
1. Если от клиента приходит пост с id != 0, значит это сохранение (обновление) существующего поста - вы ищете его в списке по id и обновляете (продумайте самостоятельно, что вы будете делать, если поста с таким id не оказалось: здесь могут быть разные стратегии)

### Результат

В качестве результата пришлите ссылку на ваш GitHub репозиторий в личном кабинете студента на сайте [netology.ru](https://netology.ru).

## WebApp Runner*

**Важно**: выполнение данного ДЗ не влияет на получение зачёта по ДЗ.

### Легенда

Не всегда удобно "таскать" за собой полноценный Tomcat (скачивать, распаковывать его и т.д.). Достаточно часто используют библиотеку [WebApp Runner](https://github.com/heroku/webapp-runner), ранее (com.github.jsimone webapp-runner).

Встраивание webapp-runner'а в ваш проект позволяет запускать его (проект) следующим образом: `java -jar target/dependency/webapp-runner.jar target/<appname>.war` (достаточно удобно для размещения на облачных платформах).

### Задача

Добавьте в свою сборку скачивание `webapp-runner`'а согласно [инструкции](https://github.com/heroku/webapp-runner#using-with-maven-in-your-project).

Убедитесь, что сборка проходит и ваш war-файл действительно запускается указанной выше командой.

### Результат

Реализуйте новую функциональность в ветке `feature/webapp-runner` вашего репозитория из предыдущего ДЗ и откройте Pull Request.

В качестве результата пришлите ссылку на ваш Pull Request на GitHub в личном кабинете студента на сайте [netology.ru](https://netology.ru).

После того, как ДЗ будет принято, сделайте `merge` для Pull Request'а.
</details>

<details><summary>Домашнее задание к занятию «2.3. Spring Web MVC»</summary>

В качестве результата пришлите ссылки на ваши GitHub-проекты в личном кабинете студента на сайте [netology.ru](https://netology.ru).

**Важно**: ознакомьтесь со ссылками, представленными на главной странице [репозитория с домашними заданиями](../README.md).

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

## Как сдавать задачи

1. Создайте на вашем компьютере Maven-проект
1. Инициализируйте в нём пустой Git-репозиторий
1. Добавьте в него готовый файл [.gitignore](../.gitignore)
1. Добавьте в этот же каталог остальные необходимые файлы
1. Сделайте необходимые коммиты
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub)
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru)

## Migration

### Легенда

Первая задача достаточно простая: вам нужно смигрировать ваше приложение на сервлетах, написанное в предыдущих ДЗ на Spring Web MVC с Embed Tomcat.

### Задача

Создайте новый проект на базе Spring MVC и Embed Tomcat и перенесите реализованную в предыдущих ДЗ функциональность.

Ваш контроллер должен выглядеть именно так, как в лекции:
```java
@RestController
@RequestMapping("/api/posts")
public class PostController {
  private final PostService service;

  public PostController(PostService service) {
    this.service = service;
  }

  @GetMapping
  public List<Post> all() {
    return service.all();
  }

  @GetMapping("/{id}")
  public Post getById(@PathVariable long id) {
    return service.getById(id);
  }

  @PostMapping
  public Post save(@RequestBody Post post) {
    return service.save(post);
  }

  @DeleteMapping("/{id}")
  public void removeById(long id) {
    service.removeById(id);
  }
}
```

Обратите внимание, что вся функциональность (CRUD), реализованная до этого, должна по-прежнему работать.

### Результат

В качестве результата пришлите ссылку на ваш GitHub проект в личном кабинете студента на сайте [netology.ru](https://netology.ru).

## Данные не удаляются*

**Важно**: данная задача не является обязательной

### Легенда

Самое плохое, что можно сделать с пользовательскими данными - это безвозвратно их удалить (они потом всегда звонят с просьбой восстановить и утверждают, что они-то точно ничего сами не удаляли). Поэтому чаще всего их не удаляют, а помечают на удаление (т.е. добавляют какое-то поле, например, `removed`).

Для простоты мы будем считать, что `/api/posts` - это API для клиентов, где они не смогут реализовать "восстановление" удалённых постов и даже просмотреть удалённые посты. Для этого будет отдельное API (позже).

Соответственно, получается, что `removeById` всего лишь выставляет это поле. Но это не всё, работа остальных методов тоже кардинально меняется:
* `all` возвращает все посты, кроме тех, у которых выставлен флаг `removed`
* `getById` возвращает пост только если у него не выставлен флаг `removed`, в противном случае кидает `NotFoundException`*
* `save` обновляет существующий пост только если у него не выставлен флаг `removed`, в противном случае кидает `NotFoundException`*

Примечание*: здесь нет идеального решения, разные люди могут вам говорить, что так можно, так нельзя и т.д. Мы же лишь скажем, что любая категоричность - это всегда плохо и вы должны понимать, что бывает по-разному, всё зависит от того, какое решение примет проектировщик API или команда.

Единственный вопрос остаётся со статус кодами. По логике, `NotFoundException` должен приводить к статус коду 404. Изучите документацию на [@ResponseStatus](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/ResponseStatus.html) и подумайте, как её применить для выставления статуса кода 404 при возникновении указанного нами Exception'а.

<details>
<summary>Подсказка</summary>

Использовать её нужно в формате `@ResponseStatus(code = HttpStatus.NOT_FOUND)`, при этом, конечно же, импортировать и `ResponseStatus` и `HttpStatus`.
</details>

### Задача

Создайте Pull Request с описанной функциональностью к проекту из первой задачи (Migration).

Решение по тому, на каком именно слое реализовать данную логику - остаётся за вами. Скажем лишь, что это точно не Controller.

Обратите внимание, что вся функциональность (CRUD), реализованная до этого, должна по-прежнему работать.

### Результат

В качестве результата пришлите:
1. Ссылку на ваш Pull Request в личном кабинете студента на сайте [netology.ru](https://netology.ru)
1. Обоснование, почему вы реализовали логику именно в том слое, в котором реализовали

</details>